"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadContractAddress = exports.saveContract = exports.contractDeployInfo = exports.deployContract = exports.getContractAt = exports.getContract = exports.getContractABI = exports.listContracts = exports.getContractBuild = exports.writeNetworkFile = exports.readNetworkFile = exports.getNetworkFile = exports.readBuildFile = exports.getBuildFile = void 0;
const file_1 = require("./file");
const path = __importStar(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
function getBuildFile(saddle_config) {
    if (saddle_config.get_build_file) {
        return saddle_config.get_build_file();
    }
    else {
        const fileName = saddle_config.trace ? `contracts-trace.json` : `contracts.json`;
        return path.join(path.resolve(process.cwd(), saddle_config.build_dir), fileName);
    }
}
exports.getBuildFile = getBuildFile;
async function readBuildFile(saddle_config) {
    if (saddle_config.read_build_file) {
        return await saddle_config.read_build_file();
    }
    else {
        let buildFile = await getBuildFile(saddle_config);
        let initialBuild = await file_1.readFile(buildFile, {}, JSON.parse);
        let extraBuildFiles = await fast_glob_1.default(saddle_config.extra_build_files);
        return await extraBuildFiles.reduce(async (accP, el) => {
            let acc = await accP;
            let newBuild = await file_1.readFile(el, {}, JSON.parse);
            return {
                ...acc,
                contracts: {
                    ...newBuild.contracts,
                    ...acc.contracts
                }
            };
        }, Promise.resolve(initialBuild));
    }
}
exports.readBuildFile = readBuildFile;
function getNetworkFile(network_config) {
    if (network_config.get_network_file) {
        return network_config.get_network_file(network_config.network);
    }
    else {
        const fileName = network_config.trace ? `${network_config.network}-trace.json` : `${network_config.network}.json`;
        return path.join(path.resolve(process.cwd(), network_config.build_dir), fileName);
    }
}
exports.getNetworkFile = getNetworkFile;
async function readNetworkFile(network_config) {
    if (network_config.read_network_file) {
        return await network_config.read_network_file(network_config.network);
    }
    else {
        let networkFile = await getNetworkFile(network_config);
        return await file_1.readFile(networkFile, {}, JSON.parse);
    }
}
exports.readNetworkFile = readNetworkFile;
async function writeNetworkFile(value, network_config) {
    if (network_config.write_network_file) {
        await network_config.write_network_file(network_config.network, value);
    }
    else {
        let networkFile = await getNetworkFile(network_config);
        await file_1.writeFile(networkFile, JSON.stringify(value, undefined, 2));
    }
}
exports.writeNetworkFile = writeNetworkFile;
async function getContractBuild(name, saddle_config) {
    let contracts = await readBuildFile(saddle_config);
    let contractsObject = contracts["contracts"] || {};
    let foundContract = Object.entries(contractsObject).find(([pathContractName, contract]) => {
        let [_, contractName] = pathContractName.split(":", 2);
        return contractName == name;
    });
    if (foundContract) {
        let [contractPath, contractBuild] = foundContract;
        contractBuild.path = contractPath.split(':')[0];
        contractBuild.version = contracts["version"];
        return contractBuild;
    }
    else {
        throw new Error(`Cannot find contract \`${name}\` in build file \`${getBuildFile(saddle_config)}\`.`);
    }
}
exports.getContractBuild = getContractBuild;
async function listContracts(network_config) {
    let contractJson = await readBuildFile(network_config);
    let networkConfig = await readNetworkFile(network_config);
    let contractSub = contractJson['contracts'] || {};
    let contractKeys = Object.keys(contractSub);
    let contracts = contractKeys.map((k) => k.split(':')[1]);
    return contracts.reduce((acc, el) => {
        return {
            ...acc,
            [el]: networkConfig[el]
        };
    }, {});
}
exports.listContracts = listContracts;
async function getContractABI(name, saddle_config) {
    const contractBuild = await getContractBuild(name, saddle_config);
    return JSON.parse(contractBuild.abi);
}
exports.getContractABI = getContractABI;
async function getContract(web3, name, saddle_config, defaultOptions) {
    const contractBuild = await getContractBuild(name, saddle_config);
    const contractAbi = JSON.parse(contractBuild.abi);
    return new web3.eth.Contract(contractAbi, undefined, defaultOptions);
    ;
}
exports.getContract = getContract;
async function getContractAt(web3, name, saddle_config, address, defaultOptions) {
    const contract = await getContract(web3, name, saddle_config, defaultOptions);
    contract.options.address = address;
    return contract;
}
exports.getContractAt = getContractAt;
async function deployContract(web3, network, name, args, network_config, defaultOptions, sendOptions) {
    const contractBuild = await getContractBuild(name, network_config);
    const web3Contract = await getContract(web3, name, network_config, defaultOptions);
    const deployer = await web3Contract.deploy({ data: '0x' + contractBuild.bin, arguments: args });
    let receiptResolveFn;
    let receiptPromise = new Promise((resolve, reject) => {
        receiptResolveFn = resolve;
    });
    let deployment = deployer.send(sendOptions).on('receipt', (receipt) => {
        return receiptResolveFn(receipt);
    });
    return {
        contract: await deployment,
        receipt: await receiptPromise
    };
}
exports.deployContract = deployContract;
function strip0x(str) {
    if (str.slice(0, 2) === "0x") {
        return str.slice(2);
    }
    else {
        return str;
    }
}
async function contractDeployInfo(web3, network, name, args, network_config, defaultOptions, sendOptions) {
    const contractBuild = await getContractBuild(name, network_config);
    const web3Contract = await getContract(web3, name, network_config, defaultOptions);
    if (Array.isArray(args)) {
        const deployer = await web3Contract.deploy({ data: '0x' + contractBuild.bin, arguments: args });
        return deployer.encodeABI();
    }
    else {
        return '0x' + contractBuild.bin + strip0x(args);
    }
}
exports.contractDeployInfo = contractDeployInfo;
async function saveContract(name, contract, network_config) {
    let curr = await readNetworkFile(network_config);
    curr[name] = contract.options.address;
    await writeNetworkFile(curr, network_config);
}
exports.saveContract = saveContract;
async function loadContractAddress(name, network_config) {
    let curr = await readNetworkFile(network_config);
    return curr[name] || undefined;
}
exports.loadContractAddress = loadContractAddress;
//# sourceMappingURL=contract.js.map