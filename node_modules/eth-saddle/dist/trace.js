"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTracer = void 0;
const sol_tracing_utils_1 = require("@compound-finance/sol-tracing-utils");
const ethereumjs_util_1 = require("ethereumjs-util");
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("./trace/utils");
const descriptor_1 = require("./trace/descriptor");
function rpc(web3, request) {
    return new Promise((okay, fail) => web3.currentProvider.send(request, (err, res) => err ? fail(err) : okay(res)));
}
async function traceTransaction(web3, txHash, traceParams = {}) {
    let { result } = await rpc(web3, { method: 'debug_traceTransaction', params: [txHash, traceParams] });
    return result;
}
function getSource(offset, sourceFile) {
    let lines = sourceFile.slice(offset.location.start.line - 1, offset.location.end.line);
    let startCol = offset.location.start.column;
    let endCol = offset.location.end.column;
    let color = chalk_1.default.blueBright;
    let sourceLine = offset.location.start.line === offset.location.end.line ?
        `${offset.fileName}:${offset.location.start.line}[${offset.location.start.column}-${offset.location.end.column}]` :
        `${offset.fileName}:${offset.location.start.line}[${offset.location.start.column}]-${offset.location.end.line}[${offset.location.end.column}]`;
    let source = lines.reduce((result, line, i) => {
        let first = i === 0;
        let last = i === lines.length - 1;
        if (first && last) {
            // Single line
            return result + line.slice(0, startCol) + color(line.slice(startCol, endCol)) + line.slice(endCol);
        }
        else {
            if (first) {
                return result + line.slice(0, startCol) + color(line.slice(startCol));
            }
            else if (last) {
                return result + color(line.slice(0, endCol)) + line.slice(endCol);
            }
            else {
                return result + color(line);
            }
        }
    }, '');
    return {
        source,
        sourceLine
    };
}
async function buildTracer(network_config) {
    let contractsData, traceCollector;
    if (network_config.artifactAdapter) {
        contractsData = await network_config.artifactAdapter.collectContractsDataAsync();
        traceCollector = new sol_tracing_utils_1.TraceCollector(network_config.artifactAdapter, true, null);
    }
    let contractTraceComponentsCache = {};
    // Note: this function will memoize its input
    async function getContractTraceComponents(address, isContractCreation = false) {
        if (isContractCreation && address in contractTraceComponentsCache) {
            return contractTraceComponentsCache[address];
        }
        let pcToSourceRange, inverted;
        if (traceCollector) {
            let checksumAddress = network_config.web3.utils.toChecksumAddress(address);
            let bytecode = await network_config.web3.eth.getCode(checksumAddress);
            let contractData = await traceCollector.getContractDataByTraceInfoIfExistsAsync(address, bytecode, isContractCreation);
            if (!contractData) {
                throw new Error(`Failed to find contract data for given bytecode at ${address}`);
            }
            const bytecodeHex = ethereumjs_util_1.stripHexPrefix(bytecode);
            const sourceMap = isContractCreation ? contractData.sourceMap : contractData.sourceMapRuntime;
            let pcToSourceRange = sol_tracing_utils_1.parseSourceMap(contractData.sourceCodes, sourceMap, bytecodeHex, contractData.sources);
            let inverted = Object.entries(contractData.sources).reduce((acc, [id, name]) => {
                return {
                    ...acc,
                    [name]: contractData.sourceCodes[id].split("\n")
                };
            }, {});
            let traceComponents = { address, pcToSourceRange, inverted };
            if (!isContractCreation) {
                contractTraceComponentsCache[address] = traceComponents;
            }
            return traceComponents;
        }
        else {
            return { address, pcToSourceRange: null, inverted: null };
        }
    }
    return async function trace(receipt, traceOpts) {
        let traceComponents = await getContractTraceComponents(receipt.contractAddress || receipt.to, receipt.contractAddress !== null);
        let { address, pcToSourceRange, inverted } = traceComponents;
        let trace = await traceTransaction(network_config.web3, receipt.transactionHash, {});
        if (traceOpts.onTrace) {
            await traceOpts.onTrace(trace);
        }
        let { logs: augmentedLogs, info: info } = descriptor_1.augmentLogs(trace.structLogs, traceOpts.constants || {});
        let filteredLogs = traceOpts.preFilter ? augmentedLogs.filter(traceOpts.preFilter) : augmentedLogs;
        if (pcToSourceRange && inverted) {
            ({ logs: filteredLogs } = await filteredLogs.reduce(async (acc, log, i, allLogs) => {
                let { logs, traceCompStack } = await acc;
                let { address, pcToSourceRange, inverted } = traceCompStack[0] || {};
                let callInput = {
                    DELEGATECALL: 4,
                    CALL: 5,
                    CALLCODE: 5,
                    STATICCALL: 4
                };
                const nextLog = allLogs[i + 1];
                if (!nextLog) {
                    // the last opcode in a tx is a STOP or RETURN, which has no cost
                    log.gasCost = 0;
                }
                else if (callInput[log.op]) {
                    let input = log.inputs[callInput[log.op]];
                    let traceComponents = await getContractTraceComponents('0x' + utils_1.trimZero(input));
                    traceCompStack = [
                        { ...traceComponents, gasRemaining: nextLog.gasCost, callIndex: i },
                        ...traceCompStack
                    ];
                }
                else if (log.op === 'RETURN') {
                    // set the gas cost of the previous call to the difference in gas between the return opcode and the call opcode
                    // a RETURN code before the end of the tx means we must be in an externall call, so we'll have gasCost and gasRemaining
                    logs[traceCompStack[0].callIndex].gasCost = traceCompStack[0].gasRemaining + nextLog.gasCost;
                    // RETURN itself is 0 cost
                    log.gasCost = 0;
                    traceCompStack = traceCompStack.slice(1);
                }
                else {
                    // debug_traceTransaction's gasCosts are off by one
                    log.gasCost = nextLog.gasCost;
                }
                log.setContract(address, traceCompStack.length - 1);
                let offset = pcToSourceRange ? pcToSourceRange[log.pc] : undefined;
                if (offset) {
                    let sourceFile = inverted[offset.fileName];
                    let { source, sourceLine } = getSource(offset, sourceFile);
                    log.setSource(source, sourceLine);
                }
                return {
                    logs: [...logs, log],
                    traceCompStack
                };
            }, Promise.resolve({ logs: [], traceCompStack: [traceComponents] })));
        }
        let postFilteredLogs = traceOpts.postFilter ? filteredLogs.filter(traceOpts.postFilter) : filteredLogs;
        if (traceOpts.execLog !== undefined) {
            let { execLog } = traceOpts;
            await Promise.all(postFilteredLogs.map((log) => execLog(log, info)));
        }
        if (traceOpts.exec !== undefined) {
            await traceOpts.exec(postFilteredLogs, info);
        }
        return postFilteredLogs;
    };
}
exports.buildTracer = buildTracer;
//# sourceMappingURL=trace.js.map