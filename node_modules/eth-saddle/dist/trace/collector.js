"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@0x/utils");
const chalk_1 = __importDefault(require("chalk"));
const ethereumjs_util_1 = require("ethereumjs-util");
const fs = __importStar(require("fs"));
const istanbul_1 = require("istanbul");
const _ = __importStar(require("lodash"));
const loglevel_1 = require("loglevel");
const mkdirp = __importStar(require("mkdirp"));
const sol_tracing_utils_1 = require("@0x/sol-tracing-utils");
const sol_tracing_utils_2 = require("@0x/sol-tracing-utils");
const mkdirpAsync = utils_1.promisify(mkdirp);
/**
 * TraceCollector is used by CoverageSubprovider to compute code coverage based on collected trace data.
 */
class TraceCollector {
    /**
     * Instantiates a TraceCollector instance
     * @param artifactAdapter Adapter for used artifacts format (0x, truffle, giveth, etc.)
     * @param isVerbose If true, we will log any unknown transactions. Otherwise we will ignore them
     * @param singleFileSubtraceHandler A handler function for computing partial coverage for a single file & subtrace
     */
    constructor(artifactAdapter, isVerbose, singleFileSubtraceHandler) {
        this._collector = new istanbul_1.Collector();
        this._artifactAdapter = artifactAdapter;
        this._logger = loglevel_1.getLogger('sol-tracing-utils');
        this._logger.setLevel(isVerbose ? loglevel_1.levels.TRACE : loglevel_1.levels.ERROR);
        this._singleFileSubtraceHandler = singleFileSubtraceHandler;
    }
    async writeOutputAsync() {
        const finalCoverage = this._collector.getFinalCoverage();
        const stringifiedCoverage = JSON.stringify(finalCoverage, null, '\t');
        await mkdirpAsync('coverage');
        fs.writeFileSync('coverage/coverage.json', stringifiedCoverage);
    }
    async getContractDataByTraceInfoIfExistsAsync(address, bytecode, isContractCreation) {
        if (this._contractsData === undefined) {
            this._contractsData = await this._artifactAdapter.collectContractsDataAsync();
        }
        const contractData = sol_tracing_utils_2.utils.getContractDataIfExists(this._contractsData, bytecode);
        if (contractData === undefined) {
            /**
             * Length chooses so that both error messages are of the same length
             * and it's enough data to figure out which artifact has a problem.
             */
            const HEX_LENGTH = 16;
            const errMsg = isContractCreation
                ? `Unable to find matching bytecode for contract creation ${chalk_1.default.bold(sol_tracing_utils_2.utils.shortenHex(bytecode, HEX_LENGTH))}, please check your artifacts. Ignoring...`
                : `Unable to find matching bytecode for contract address ${chalk_1.default.bold(address)}, please check your artifacts. Ignoring...`;
            this._logger.warn(errMsg);
        }
        return contractData;
    }
    async computeSingleTraceCoverageAsync(subTraceInfo) {
        const isContractCreation = subTraceInfo.address === 'NEW_CONTRACT';
        const bytecode = isContractCreation
            ? subTraceInfo.bytecode
            : subTraceInfo.runtimeBytecode;
        const contractData = await this.getContractDataByTraceInfoIfExistsAsync(subTraceInfo.address, bytecode, isContractCreation);
        if (contractData === undefined) {
            return;
        }
        const bytecodeHex = ethereumjs_util_1.stripHexPrefix(bytecode);
        const sourceMap = isContractCreation ? contractData.sourceMap : contractData.sourceMapRuntime;
        console.log("parsing source map");
        const pcToSourceRange = sol_tracing_utils_1.parseSourceMap(contractData.sourceCodes, sourceMap, bytecodeHex, contractData.sources);
        console.log("parsed source map");
        _.map(contractData.sources, (_sourcePath, fileIndex) => {
            const singleFileCoverageForTrace = this._singleFileSubtraceHandler(contractData, subTraceInfo.subtrace, pcToSourceRange, _.parseInt(fileIndex));
            this._collector.add(singleFileCoverageForTrace);
        });
    }
}
exports.TraceCollector = TraceCollector;
//# sourceMappingURL=collector.js.map