#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCli = void 0;
const yargs_1 = __importDefault(require("yargs"));
const compile_1 = require("./cli/commands/compile");
const console_1 = require("./cli/commands/console");
const contracts_1 = require("./cli/commands/contracts");
const import_1 = require("./cli/commands/import");
const deploy_1 = require("./cli/commands/deploy");
const match_1 = require("./cli/commands/match");
const verify_1 = require("./cli/commands/verify");
const init_1 = require("./cli/commands/init");
const test_1 = require("./cli/commands/test");
const script_1 = require("./cli/commands/script");
var saddle_1 = require("./saddle");
Object.defineProperty(exports, "getSaddle", { enumerable: true, get: function () { return saddle_1.getSaddle; } });
const utils_1 = require("./utils");
const stream_1 = require("stream");
const fs_1 = require("fs");
function transformArgs(contractArgsRaw) {
    const transformers = {
        array: (arg) => arg.split(',').filter(x => x.length > 0),
        address: (arg) => arg.toString(),
        json: (arg) => JSON.parse(arg)
    };
    return contractArgsRaw.map((arg) => {
        // Check if arg is valid json string - tuple or an array of tuples,
        // otherwise split based on the last occurance of ':'
        let [raw, type] = utils_1.isValidJSONString(arg) ? [arg, 'json'] : arg.toString().split(/\:(?=[^\:]+$)/);
        if (!type) {
            if (Number.isInteger(arg)) {
                type = 'number';
            }
            else if (arg.includes(',')) {
                type = 'array';
            }
        }
        if (type && transformers[type]) {
            return transformers[type](raw);
        }
        else {
            return arg;
        }
    });
}
function getCli() {
    return yargs_1.default
        .option('network', { alias: 'n', description: 'Chosen network', type: 'string', default: 'development' })
        .count('verbose')
        .alias('v', 'verbose')
        .command('compile', 'Compiles all contracts', (yargs) => {
        return yargs
            .option('trace', {
            describe: 'Build contracts with detailed debug information',
            type: 'boolean',
            default: false
        })
            .option('pretty', {
            describe: 'Pretty format the JSON',
            type: 'boolean',
            default: true
        });
    }, (argv) => {
        argv.compileResult = compile_1.compile(argv.trace, argv.verbose, argv.pretty);
    })
        .command('console', 'Starts a saddle console', (yargs) => {
        return yargs
            .option('trace', {
            describe: 'Build contracts with detailed debug information',
            type: 'boolean',
            default: false
        })
            .option('script', {
            describe: 'Run a given script instead of start a console',
            type: 'string',
            default: null,
            alias: 's'
        })
            .option('eval', {
            describe: 'Evaluate the given JavaScript code',
            type: 'string',
            default: null,
            alias: 'e'
        });
    }, (argv) => {
        let scriptArg = argv.script;
        let evalArg = argv.eval;
        if (scriptArg && evalArg) {
            throw new Error("Cannot use --eval and --script options together");
        }
        let input;
        if (scriptArg !== null) {
            input = fs_1.createReadStream(scriptArg);
        }
        else if (evalArg !== null) {
            let codes = Array.isArray(evalArg) ? evalArg.map((e) => e + ';\n') : [evalArg];
            input = stream_1.Readable.from(codes);
        }
        console_1.startConsole(input, argv.network, argv.trace, argv.verbose);
    })
        .command('contracts', 'Display given contracts', (yargs) => yargs, (argv) => {
        argv.contractsResult = contracts_1.listContracts(argv.network);
    })
        .command('script <script>', 'Run a given script', (yargs) => {
        return yargs
            .positional('script', {
            describe: 'Script to run',
            type: 'string'
        });
    }, (argv) => {
        const script = argv.script; // required
        argv.scriptResult = script_1.runScript(argv.network, script, argv._.slice(1), argv.verbose);
    })
        .command('deploy <contract>', 'Deploy a contract to given network', (yargs) => {
        return yargs
            .positional('contract', {
            describe: 'Contract to deploy (e.g. myContract.sol)',
            type: 'string'
        });
    }, (argv) => {
        const contract = argv.contract; // required
        const [, ...contractArgsRaw] = argv._;
        const contractArgs = transformArgs(contractArgsRaw);
        argv.deployResult = deploy_1.deploy(argv.network, contract, contractArgs, false, argv.verbose);
    })
        .command('match <address> <contract>', 'Checks if a contract matches current build', (yargs) => {
        return yargs
            .positional('address', {
            describe: 'Address of on-chain contract to match',
            type: 'string'
        }).positional('contract', {
            describe: 'Contract to match (e.g. myContract.sol)',
            type: 'string'
        }).option('raw', {
            alias: 'r',
            describe: 'Args should be passed-through without transformation',
            type: 'boolean',
            default: false
        });
    }, (argv) => {
        const address = argv.address; // required
        const contract = argv.contract; // required
        const [, ...contractArgsRaw] = argv._;
        const contractArgs = argv.raw ? argv._[1] : transformArgs(contractArgsRaw);
        argv.matchResult = match_1.match(argv.network, address, contract, contractArgs, false, argv.verbose);
    })
        .command('import <address>', 'Imports a contract from remote source', (yargs) => {
        return yargs
            .positional('address', {
            describe: 'Address of contract to read',
            type: 'string'
        })
            .option('source', {
            describe: 'Source to load contract from (e.g. etherscan)',
            type: 'string',
            default: 'etherscan'
        })
            .option('outdir', {
            describe: 'Directory to place build file',
            type: 'string',
            default: './remote'
        });
    }, (argv) => {
        const address = argv.address; // required
        import_1.loadContract(argv.source, argv.network, address, argv.outdir, argv.verbose);
    })
        .command('verify <apiKey> <address> <contract>', 'Verify a given contract on Etherscan', (yargs) => {
        return yargs
            .positional('apiKey', {
            describe: 'API Key from Etherscan',
            type: 'string'
        })
            .positional('address', {
            describe: 'Address of contract to verify',
            type: 'string'
        })
            .positional('contract', {
            describe: 'Contract to deploy (e.g. myContract.sol)',
            type: 'string'
        })
            .option('raw', {
            alias: 'r',
            describe: 'Args should be passed-through without transformation',
            type: 'boolean',
            default: false
        });
    }, (argv) => {
        const apiKey = argv.apiKey; // required
        const address = argv.address; // required
        const contract = argv.contract; // required
        const [, ...contractArgsRaw] = argv._;
        const contractArgs = argv.raw ? argv._[1] : transformArgs(contractArgsRaw);
        verify_1.verify(argv.network, apiKey, address, contract, contractArgs, argv.verbose);
    })
        .command('test', 'Run contract tests', (yargs) => yargs, (argv) => {
        test_1.test(argv, false, argv.verbose);
    })
        .command('coverage', 'Run contract coverage tests', (yargs) => yargs, (argv) => {
        test_1.test(argv, true, argv.verbose);
    })
        .command('init', 'Build initial configuration file', (yargs) => yargs, (argv) => {
        init_1.init(argv.verbose);
    })
        .help()
        .alias('help', 'h')
        .demandCommand()
        .recommendCommands()
        .strict();
}
exports.getCli = getCli;
if (require.main === module) {
    getCli().parse();
}
//# sourceMappingURL=cli.js.map