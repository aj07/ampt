"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const util = __importStar(require("util"));
const fs = __importStar(require("fs"));
const etherscan_1 = require("./etherscan");
async function loadContract(source, network, address, outfile, verbose) {
    switch (source) {
        case 'etherscan':
            return await loadEtherscanContract(network, address, outfile, verbose);
        default:
            throw new Error(`Unknown source \`${source}\`, expected one of [etherscan]`);
    }
}
exports.loadContract = loadContract;
async function getEtherscanApiData(network, address) {
    let apiUrl = await etherscan_1.getEtherscanApiUrl(network);
    let result = await etherscan_1.get(apiUrl, { module: 'contract', action: 'getsourcecode', address });
    if (result.status !== '1') {
        throw new Error(`Etherscan Error: ${result.message}`);
    }
    let s = result.result[0];
    if (s.ABI === "Contract source code not verified") {
        throw new Error("Contract source code not verified");
    }
    return {
        source: s.SourceCode,
        abi: JSON.parse(s.ABI),
        contract: s.ContractName,
        compiler: s.CompilerVersion,
        optimized: s.OptimizationUsed !== '0',
        optimzationRuns: Number(s.Runs),
        constructorArgs: s.ConstructorArguments
    };
}
async function getContractCreationCode(network, address) {
    let url = `${await etherscan_1.getEtherscanUrl(network)}/address/${address}#code`;
    let result = await etherscan_1.get(url, {}, null);
    let regex = /<div id='verifiedbytecode2'>[\s\r\n]*([0-9a-fA-F]*)[\s\r\n]*<\/div>/g;
    let matches = [...result.matchAll(regex)];
    if (matches.length === 0) {
        throw new Error('Failed to pull deployed contract code from Etherscan');
    }
    return matches[0][1];
}
async function loadEtherscanContract(network, address, outfile, verbose) {
    // Okay, this is where the fun begins, let's gather as much information as we can
    let { source, abi, contract, compiler, optimized, optimzationRuns, constructorArgs } = await getEtherscanApiData(network, address);
    let contractCreationCode = await getContractCreationCode(network, address);
    let encodedABI = JSON.stringify(abi);
    let contractSource = `contracts/${contract}.sol:${contract}`;
    let contractBuild = {
        contracts: {
            [contractSource]: {
                abi: encodedABI,
                bin: contractCreationCode,
                metadata: JSON.stringify({
                    compiler: {
                        version: compiler
                    },
                    language: "Solidity",
                    output: {
                        abi: encodedABI
                    },
                    devdoc: {},
                    sources: {
                        [contractSource]: {
                            content: source,
                            keccak256: ""
                        }
                    },
                    version: 1
                })
            }
        },
        version: compiler
    };
    await util.promisify(fs.writeFile)(outfile, JSON.stringify(contractBuild, null, 2));
}
exports.loadEtherscanContract = loadEtherscanContract;
//# sourceMappingURL=load_contract.js.map