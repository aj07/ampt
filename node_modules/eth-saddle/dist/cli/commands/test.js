"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = void 0;
const cli_1 = require("jest-cli/build/cli");
const jest_1 = __importDefault(require("jest"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const logger_1 = require("../../logger");
async function test(argv, coverage, verbose) {
    logger_1.info(`Saddle: running contract ${coverage ? 'coverage' : 'tests'} with jest...\n`, verbose);
    // Parse the saddle config
    const config = await config_1.loadConfig();
    if (argv._[0] == 'coverage') {
        argv._[0] = 'test';
    }
    // Parse command line args, possibly override testMatch based on remaining argv
    const jestArgv = cli_1.buildArgv(argv._);
    const testArgs = argv._[0] == 'test' ? argv._.slice(1) : argv._;
    const testPats = testArgs.map(a => `**/${a}`);
    logger_1.info(`Jest args: ${JSON.stringify(jestArgv)}`, verbose);
    const res = await jest_1.default.runCLI({
        testMatch: testPats.length ? testPats : config.tests,
        testEnvironment: path_1.default.join(__dirname, '..', '..', 'test_env.js'),
        testEnvironmentOptions: { coverage: coverage.toString() },
        ...jestArgv
    }, [process.cwd()]);
    if (!res.results.success) {
        process.exitCode = 1;
    }
}
exports.test = test;
//# sourceMappingURL=test.js.map