"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const contract_1 = require("../../contract");
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
const logger_1 = require("../logger");
const saddle_1 = require("../../saddle");
const etherscan_1 = require("./etherscan");
async function sleep(timeout) {
    return new Promise((resolve, _reject) => {
        setTimeout(() => resolve(), timeout);
    });
}
async function checkStatus(url, token, verbose) {
    logger_1.info(`Checking status of ${token}...`, verbose);
    // Potential results:
    // { status: '0', message: 'NOTOK', result: 'Fail - Unable to verify' }
    // { status: '0', message: 'NOTOK', result: 'Pending in queue' }
    // { status: '1', message: 'OK', result: 'Pass - Verified' }
    let result = await etherscan_1.get(url, {
        guid: token,
        module: "contract",
        action: "checkverifystatus"
    });
    logger_1.info(JSON.stringify(result), verbose);
    if (result.result === "Pending in queue") {
        await sleep(5000);
        return await checkStatus(url, token, verbose);
    }
    if (result.result.startsWith('Fail')) {
        throw new Error(`Etherscan failed to verify contract: ${result.message} "${result.result}"`);
    }
    if (Number(result.status) !== 1) {
        throw new Error(`Etherscan Error: ${result.message} "${result.result}"`);
    }
    logger_1.info(`Verification result ${result.result}...`, verbose);
}
const importRegex = /^[ \t]*import\s*\"([^\"]+)\"[\s;]*$\n?/mig;
const pragmaRegex = /^[ \t]*(pragma[^;]+;)$\n?/mig;
function matchAll(content, regex, index = 1) {
    const results = [];
    while (true) {
        let match = regex.exec(content);
        if (!match) {
            break;
        }
        results.push(index ? match[index] : match);
    }
    return results;
}
function orderEntries(sources) {
    const entries = Object.entries(sources);
    const deps = entries.reduce((acc, [name, { content: content }]) => {
        const entryDeps = matchAll(content, importRegex, 1)
            .map(file => path.join(path.dirname(name), file));
        return {
            ...acc,
            [name]: entryDeps
        };
    }, {});
    function addDeps(includedDeps, totalDeps) {
        if (Object.keys(totalDeps).length === 0) {
            return includedDeps;
        }
        const originalLength = includedDeps.length;
        Object.entries(totalDeps).forEach(([name, deps]) => {
            const sat = deps.every((dep) => includedDeps.includes(dep));
            if (sat) {
                includedDeps.push(name);
                delete totalDeps[name];
            }
        });
        if (includedDeps.length === originalLength) {
            throw new Error(`Cannot satisify dependency tree: included: ${JSON.stringify(includedDeps)}, total: ${JSON.stringify(totalDeps)}`);
        }
        return addDeps(includedDeps, totalDeps);
    }
    const order = addDeps([], deps);
    return order.map((el) => [el, sources[el]]);
}
function flattenSources(sources, contractName) {
    const flattened = orderEntries(sources).reduce((acc, [name, { content: content }]) => {
        return acc + content.replace(importRegex, '');
    }, '');
    const pragmas = matchAll(flattened, pragmaRegex, 1);
    const pragmaHeader = [...new Set(pragmas)].join("\n");
    return pragmaHeader + "\n" + flattened.replace(pragmaRegex, '');
}
function getConstructorABI(abi, contractArgs) {
    const constructorAbi = abi.find((x) => x.type === 'constructor');
    if (!constructorAbi) {
        return "0x";
    }
    else {
        return web3_eth_abi_1.default.encodeParameters(constructorAbi.inputs, contractArgs);
    }
}
async function etherscanVerify(network, apiKey, contractName, contractArgs, optimizations, source, verbose) {
    logger_1.info(`Verifying contract ${contractName}${source ? ` from ${source}` : ""} with args ${JSON.stringify(contractArgs)}`, verbose);
    let saddle = await saddle_1.getSaddle(network);
    let contractAddress = await contract_1.loadContractAddress(contractName, saddle.network_config);
    if (!contractAddress) {
        throw new Error(`Cannot find contract ${contractName}- was it deployed to ${network}?`);
    }
    let contractSource = source || contractName;
    let contractBuild = await contract_1.getContractBuild(contractSource, saddle.saddle_config);
    let metadata = JSON.parse(contractBuild.metadata);
    let sourceCode = await flattenSources(metadata.sources, contractName);
    let compilerVersion = contractBuild.version.replace(/(\.Emscripten)|(\.clang)|(\.Darwin)|(\.appleclang)/gi, '');
    let constructorAbi = Array.isArray(contractArgs) ? getConstructorABI(JSON.parse(contractBuild.abi), contractArgs) : contractArgs;
    let url = etherscan_1.getEtherscanApiUrl(network);
    const verifyData = {
        apikey: apiKey,
        module: 'contract',
        action: 'verifysourcecode',
        contractaddress: contractAddress,
        sourceCode: sourceCode,
        contractname: contractName,
        compilerversion: `v${compilerVersion}`,
        optimizationUsed: optimizations > 0 ? '1' : '0',
        runs: optimizations > 0 ? optimizations.toString() : '',
        constructorArguements: constructorAbi.slice(2)
    };
    logger_1.info(`Verifying ${contractName} at ${contractAddress} with compiler version ${compilerVersion}...`, verbose);
    logger_1.debug(`Etherscan API Request:\n\n${JSON.stringify(verifyData, undefined, 2)}`, verbose);
    logger_1.debug(sourceCode, verbose);
    // Potential results
    // {"status":"0","message":"NOTOK","result":"Invalid constructor arguments provided. Please verify that they are in ABI-encoded format"}
    // {"status":"1","message":"OK","result":"usjpiyvmxtgwyee59wnycyiet7m3dba4ccdi6acdp8eddlzdde"}
    let result = await etherscan_1.post(url, verifyData);
    if (Number(result.status) === 0 || result.message !== "OK") {
        if (result.result.includes('Contract source code already verified')) {
            logger_1.warn(`Contract already verified`, verbose);
        }
        else {
            throw new Error(`Etherscan Error: ${result.message}: ${result.result}`);
        }
    }
    else {
        return await checkStatus(url, result.result, verbose);
    }
}
exports.etherscanVerify = etherscanVerify;
//# sourceMappingURL=etherscan-verify.js.map