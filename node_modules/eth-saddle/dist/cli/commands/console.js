"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startConsole = exports.getContracts = void 0;
const repl_1 = __importDefault(require("repl"));
const path_1 = __importDefault(require("path"));
const saddle_1 = require("../../saddle");
const cli_1 = require("../../cli");
const logger_1 = require("../../logger");
const utils_1 = require("../../utils");
const completion_1 = require("./console/completion");
function lowerCase(str) {
    if (str === "") {
        return "";
    }
    else {
        return str[0].toLowerCase() + str.slice(1);
    }
}
async function wrapError(p, that) {
    try {
        return await p;
    }
    catch (err) {
        console.error(`Error: ${err}`);
    }
    finally {
        that.displayPrompt();
    }
}
async function getContracts(saddle) {
    let contracts = await saddle.listContracts();
    let contractInsts = await Object.entries(contracts).reduce(async (acc, [contract, address]) => {
        if (address) {
            return {
                ...await acc,
                [contract]: await saddle.getContractAt(contract, address)
            };
        }
        else {
            return await acc;
        }
    }, {});
    return {
        contracts,
        contractInsts
    };
}
exports.getContracts = getContracts;
function defineCommands(r, saddle, network, contracts) {
    r.defineCommand('deploy', {
        help: 'Deploy a given contract',
        action(...args) {
            this.clearBufferedCommand();
            let that = this;
            cli_1.getCli().parse(`deploy -n ${network} ${args.join(" ")}`, function (err, argv, output) {
                if (err) {
                    console.error(`Error: ${err}`);
                }
                else {
                    console.log(output);
                    wrapError(argv.deployResult, that).then((res) => {
                        if (res) {
                            getContracts(saddle).then(({ contracts, contractInsts }) => {
                                r.completer = completion_1.getCompletions(r.originalCompleter, contracts);
                                defineContracts(r, saddle, contractInsts);
                                defineCommands(r, saddle, network, contracts);
                                that.displayPrompt();
                            });
                        }
                    });
                }
            });
        }
    });
    r.defineCommand('verify', {
        help: 'Verify a given contract on Etherscan',
        action(...args) {
            this.clearBufferedCommand();
            let that = this;
            cli_1.getCli().parse(`verify -n ${network} ${args.join(" ")}`, function (err, argv, output) {
                if (err) {
                    console.error(`Error: ${err}`);
                }
                else {
                    console.log(output);
                    wrapError(argv.verifyResult, that);
                }
            });
        }
    });
    r.defineCommand('match', {
        help: 'Matches a given contract to an Ethereum deploy contract',
        action(...args) {
            this.clearBufferedCommand();
            let that = this;
            cli_1.getCli().parse(`match -n ${network} ${args.join(" ")}`, function (err, argv, output) {
                if (err) {
                    console.error(`Error: ${err}`);
                }
                else {
                    console.log(output);
                    wrapError(argv.matchResult, that);
                }
            });
        }
    });
    r.defineCommand('compile', {
        help: 'Re-compile contracts',
        action(name) {
            this.clearBufferedCommand();
            let that = this;
            cli_1.getCli().parse(`compile ${name}`, function (err, argv, output) {
                if (err) {
                    console.error(`Error: ${err}`);
                }
                else {
                    console.log(output);
                    wrapError(argv.compileResult, that).then((res) => {
                        if (res) {
                            getContracts(saddle).then(({ contracts, contractInsts }) => {
                                r.completer = completion_1.getCompletions(r.originalCompleter, contracts);
                                defineContracts(r, saddle, contractInsts);
                                defineCommands(r, saddle, network, contracts);
                                that.displayPrompt();
                            });
                        }
                    });
                }
            });
        }
    });
    r.defineCommand('contracts', {
        help: 'Lists known contracts',
        action(name) {
            this.clearBufferedCommand();
            let that = this;
            cli_1.getCli().parse(`contracts ${name}`, function (err, argv, output) {
                if (err) {
                    console.error(`Error: ${err}`);
                }
                else {
                    console.log(output);
                    wrapError(argv.contractsResult, that);
                }
            });
        }
    });
    r.defineCommand('network', {
        help: 'Show given network',
        action(name) {
            this.clearBufferedCommand();
            console.log(`Network: ${network}`);
            this.displayPrompt();
        }
    });
    r.defineCommand('provider', {
        help: 'Show given provider',
        action(name) {
            this.clearBufferedCommand();
            console.log(`Provider: ${utils_1.describeProvider(saddle.web3.currentProvider)}`);
            this.displayPrompt();
        }
    });
    r.defineCommand('from', {
        help: 'Show default from address',
        action(name) {
            this.clearBufferedCommand();
            console.log(`From: ${saddle.network_config.default_account}`);
            this.displayPrompt();
        }
    });
    r.defineCommand('deployed', {
        help: 'Show given deployed contracts',
        action(name) {
            this.clearBufferedCommand();
            Object.entries(contracts).forEach(([contract, deployed]) => {
                console.log(`${contract}: ${deployed || ""}`);
            });
            this.displayPrompt();
        }
    });
}
function defineContracts(r, saddle, contractInsts) {
    Object.entries(contractInsts).forEach(([contract, contractInst]) => {
        Object.defineProperty(r.context, lowerCase(contract), {
            configurable: true,
            enumerable: true,
            value: contractInst
        });
    });
}
async function startConsole(input, network, trace, verbose) {
    let saddle = await saddle_1.getSaddle(network);
    let { contracts, contractInsts } = await getContracts(saddle);
    logger_1.info(`Saddle console on network ${network} ${utils_1.describeProvider(saddle.web3.currentProvider)}${trace ? ' (Trace)' : ''}`, verbose);
    logger_1.info(`Deployed ${network} contracts`, verbose);
    Object.entries(contracts).forEach(([contract, deployed]) => {
        if (deployed) {
            console.log(`\t${lowerCase(contract)}: ${deployed}`);
        }
    });
    let r = repl_1.default.start({
        prompt: '> ',
        input: input,
        output: input ? process.stdout : undefined,
        terminal: input ? false : undefined
    });
    if (typeof (r.setupHistory) === 'function') {
        r.setupHistory(path_1.default.join(process.cwd(), '.saddle_history'), (err, repl) => null);
    }
    r.originalCompleter = r.completer;
    r.completer = completion_1.getCompletions(r.completer, contracts);
    defineCommands(r, saddle, network, contracts);
    Object.defineProperty(r.context, 'saddle', {
        configurable: false,
        enumerable: true,
        value: saddle
    });
    Object.keys(saddle).forEach((key) => {
        Object.defineProperty(r.context, key, {
            configurable: false,
            enumerable: typeof (saddle[key]) !== 'function',
            value: saddle[key]
        });
    });
    defineContracts(r, saddle, contractInsts);
    process.on('uncaughtException', () => console.log('Error'));
}
exports.startConsole = startConsole;
//# sourceMappingURL=console.js.map