"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.match = void 0;
const contract_1 = require("../../contract");
const saddle_1 = require("../../saddle");
const logger_1 = require("../../logger");
const jest_diff_1 = require("jest-diff");
async function match(network, address, contractName, contractArgs, trace, verbose) {
    let saddle = await saddle_1.getSaddle(network);
    logger_1.info(`Matching contract at ${address} to ${contractName} with args ${JSON.stringify(contractArgs)}`, verbose);
    const callOptions = {
        ...saddle.network_config.defaultOptions,
        from: saddle.account
    };
    let contractCode = await saddle.web3.eth.getCode(address);
    if (contractCode === '0x') {
        throw new Error(`Match Failed: No contract code found at ${address} on ${network}`);
    }
    let deploymentABI = await contract_1.contractDeployInfo(saddle.web3, network, contractName, contractArgs, saddle.network_config, saddle.network_config.defaultOptions, callOptions);
    let expectedBytecode = await saddle.web3.eth.call({
        ...callOptions,
        to: undefined,
        data: deploymentABI
    });
    if (expectedBytecode === '0x') {
        throw new Error(`Match Failed: Contract "${contractName}" creation reverted on ${network}`);
    }
    if (expectedBytecode != contractCode) {
        logger_1.error(jest_diff_1.diffStringsUnified(expectedBytecode, contractCode), verbose);
        throw new Error(`Match Failed: Mismatched bytecode`);
    }
    logger_1.info(`âœ… Successfully matched ${contractName} to ${address} with args ${JSON.stringify(contractArgs)}`, verbose);
}
exports.match = match;
//# sourceMappingURL=match.js.map